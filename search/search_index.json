{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to ebakus \u00b6 The ebakus development stack allows developers to create highly responsive and frictionless decentralized applications that are a delight for users to use. The backbone of the ebakus development stack is the ebakus blockchain. It is fast, it has free transactions while remaining sybil resistant and is 100% backwards compatible with ethereum\u2019s go-ethereum node. This means that everything you have built for ethereum can be easily ported to work with ebakus. Besides the performance and accessibility gains, ebakus also extends the EVM with ebakusDB. A decentralized transactional database that makes handling of large datasets a breeze. It has tables with multiple indexes and allows to sort large datasets fast and easy. DPOS consensus \u00b6 Ebakus owes its low latency and high throuput to the Delegated Proof of Stake (DPOS) consensus algorithm that was originally introduced by Dan Larimer and first brought into production in bitshares. In DPOS the blocks are produced by the block producers, which are elected through a continuous approval voting system. Block producers are selected among a number of nodes willing to produce blocks called witnesses . Anyone can choose to become a witness, but only those that accumulate the most votes acquire the right to produce blocks. The voting power of each stake holder in the network is proportional to their stake -the number of tokens they hold- in the network. This creates a significantly more agile and attack resilient system than POW. A DPOS system can quickly heal in the events of byzantine actors trying to manipulate the network. Ebakus has 21 block producers, the 20 top voted witnesses become block producers the 21st is randomly selected by the top voted 21-40 witnesses to incentivise them to run their infrastructure and make sure that backup block producers are available. The ebakus blockchain by default produces one block every second and at each second only one producer has the authority to produce a block. Free transactions \u00b6 Blockchains today use fees in order to achieve two main goals. First, to mitigate malicious unsolicited flooding of the network with a huge number of transactions in order to affect the quality of service for normal operations, and use up storage and processing capacity. Second, to incentivise the miners or block producers as they collect those fees. Adding fees to every transaction greatly hinders the usability of a blockchain. One of our main design goal with ebakus software is to provide free transactions. We do this by solving the two aforementioned problems. We solve the incentive problem by using inflation. The block producers don\u2019t depend on the fees of transactions as the software constantly creates new ebakus coins as a reward for them. So now, we have to address the spamming of the network in order to make the inflation truly compensate for the lack of fees additionally to maintaining the quality of service. We achieve this by utilising an algorithm that uses proof of work in combination with proof of stake. The initial invention of PoW was actually for use in mitigating network denial of service. Most blockchains ended up using fees in order to make it expensive to attack the network, while killing usability and eventually failing to maintain quality of service. In ebakus the network maintains a PoW quantum value. This is the minimum work required by a non stake holder -we will come back to that- for the unit operation on the network. Each operation on the network requires to consume a number PoW quanta in order to be accepted depending on the complexity of computation, the storage requirements, etc. The block providers adjust this PoW quantum to the level that allows normal operation of the network. For example if the network is idle with very little transactions being processed, transactions will require very low PoW to be accepted. In the event someone starts spamming the network with transactions the PoW quantum will be increased so it becomes computationally expensive for him to continue doing so. However, in order to achieve quality of service for the legitimate users of the network ebakus does not operate entirely on the global PoW quantum. The global PoW quantum essentially the work quantum required by accounts holding zero amount of ebakus coins. The actual work quantum accepted is adjusted for each account as a function of its stake. Accounts that hold more ebakus coins -and hence have more stake- have a lesser PoW quantum. The PoW quantum is adjusted in a way that, at anytime, the network resources are allocated proportionally to all the stake holders sending transactions. Ebakus wallets will be able to recalculate the PoW required to send a transaction, so even in cases that the account has zero stake and the network is congested, the user experience will be smooth. The EBK token \u00b6 The ebk token is the native token of the ebakus network, its main uses are to vote for block producers and secure the infrastructure of the network to be staked and allow clients to do less proof of work in order to send transactions to the network ebakusDB \u00b6 Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/update/delete single or multiple rows of data Do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance. The ebakus development stack \u00b6 The ebakus development stack consists of the ebakus node: DPOS, 1 second blocks, ebakusDB web3-ebakus: is an extentention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library: can be included on any static site and provide an interface to the ebakus blockchain through the web wallet. the ebakus web wallet: Is the interface to the ebakus network. The ebakus development stack allows for applications that are s easy to use as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models). Besides the speed, the key to achieving great UX is avoiding transaction costs either in the form of fees or complicated resource systems, while also remaining sybil resistant. Building on ebakus \u00b6 ebakus is quite easy to pick up especially for ethereum and tron developers try our getting started with ebakus development article to familiarize yourself with the ebakus development stack and start building apps in no time.","title":"Introduction to Ebakus"},{"location":"#introduction-to-ebakus","text":"The ebakus development stack allows developers to create highly responsive and frictionless decentralized applications that are a delight for users to use. The backbone of the ebakus development stack is the ebakus blockchain. It is fast, it has free transactions while remaining sybil resistant and is 100% backwards compatible with ethereum\u2019s go-ethereum node. This means that everything you have built for ethereum can be easily ported to work with ebakus. Besides the performance and accessibility gains, ebakus also extends the EVM with ebakusDB. A decentralized transactional database that makes handling of large datasets a breeze. It has tables with multiple indexes and allows to sort large datasets fast and easy.","title":"Introduction to ebakus"},{"location":"#dpos-consensus","text":"Ebakus owes its low latency and high throuput to the Delegated Proof of Stake (DPOS) consensus algorithm that was originally introduced by Dan Larimer and first brought into production in bitshares. In DPOS the blocks are produced by the block producers, which are elected through a continuous approval voting system. Block producers are selected among a number of nodes willing to produce blocks called witnesses . Anyone can choose to become a witness, but only those that accumulate the most votes acquire the right to produce blocks. The voting power of each stake holder in the network is proportional to their stake -the number of tokens they hold- in the network. This creates a significantly more agile and attack resilient system than POW. A DPOS system can quickly heal in the events of byzantine actors trying to manipulate the network. Ebakus has 21 block producers, the 20 top voted witnesses become block producers the 21st is randomly selected by the top voted 21-40 witnesses to incentivise them to run their infrastructure and make sure that backup block producers are available. The ebakus blockchain by default produces one block every second and at each second only one producer has the authority to produce a block.","title":"DPOS consensus"},{"location":"#free-transactions","text":"Blockchains today use fees in order to achieve two main goals. First, to mitigate malicious unsolicited flooding of the network with a huge number of transactions in order to affect the quality of service for normal operations, and use up storage and processing capacity. Second, to incentivise the miners or block producers as they collect those fees. Adding fees to every transaction greatly hinders the usability of a blockchain. One of our main design goal with ebakus software is to provide free transactions. We do this by solving the two aforementioned problems. We solve the incentive problem by using inflation. The block producers don\u2019t depend on the fees of transactions as the software constantly creates new ebakus coins as a reward for them. So now, we have to address the spamming of the network in order to make the inflation truly compensate for the lack of fees additionally to maintaining the quality of service. We achieve this by utilising an algorithm that uses proof of work in combination with proof of stake. The initial invention of PoW was actually for use in mitigating network denial of service. Most blockchains ended up using fees in order to make it expensive to attack the network, while killing usability and eventually failing to maintain quality of service. In ebakus the network maintains a PoW quantum value. This is the minimum work required by a non stake holder -we will come back to that- for the unit operation on the network. Each operation on the network requires to consume a number PoW quanta in order to be accepted depending on the complexity of computation, the storage requirements, etc. The block providers adjust this PoW quantum to the level that allows normal operation of the network. For example if the network is idle with very little transactions being processed, transactions will require very low PoW to be accepted. In the event someone starts spamming the network with transactions the PoW quantum will be increased so it becomes computationally expensive for him to continue doing so. However, in order to achieve quality of service for the legitimate users of the network ebakus does not operate entirely on the global PoW quantum. The global PoW quantum essentially the work quantum required by accounts holding zero amount of ebakus coins. The actual work quantum accepted is adjusted for each account as a function of its stake. Accounts that hold more ebakus coins -and hence have more stake- have a lesser PoW quantum. The PoW quantum is adjusted in a way that, at anytime, the network resources are allocated proportionally to all the stake holders sending transactions. Ebakus wallets will be able to recalculate the PoW required to send a transaction, so even in cases that the account has zero stake and the network is congested, the user experience will be smooth.","title":"Free transactions"},{"location":"#the-ebk-token","text":"The ebk token is the native token of the ebakus network, its main uses are to vote for block producers and secure the infrastructure of the network to be staked and allow clients to do less proof of work in order to send transactions to the network","title":"The EBK token"},{"location":"#ebakusdb","text":"Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/update/delete single or multiple rows of data Do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance.","title":"ebakusDB"},{"location":"#the-ebakus-development-stack","text":"The ebakus development stack consists of the ebakus node: DPOS, 1 second blocks, ebakusDB web3-ebakus: is an extentention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library: can be included on any static site and provide an interface to the ebakus blockchain through the web wallet. the ebakus web wallet: Is the interface to the ebakus network. The ebakus development stack allows for applications that are s easy to use as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models). Besides the speed, the key to achieving great UX is avoiding transaction costs either in the form of fees or complicated resource systems, while also remaining sybil resistant.","title":"The ebakus development stack"},{"location":"#building-on-ebakus","text":"ebakus is quite easy to pick up especially for ethereum and tron developers try our getting started with ebakus development article to familiarize yourself with the ebakus development stack and start building apps in no time.","title":"Building on ebakus"},{"location":"becoming-a-block-producer/","text":"","title":"Becoming a Block Producer"},{"location":"migrating-your-erc-20-ebk-to-native-ebk-for-the-mainnet/","text":"","title":"Migrating your ERC-20 EBK to Native EBK for the mainnet"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/","text":"Getting started with ebakus development \u00b6 ebakus based decentralized applications consist of two parts the business logic that is developed through smart contracts in the solidity language and runs on the ebakus network the client logic that interfaces with the smart contract. To enable developers produce highly responsive and frictionless decentralized applications that are a delight for users to use, we have created the ebakus development stack. The ebakus development stack \u00b6 The ebakus development stack consists of the ebakus node: DPOS, 1 second blocks, ebakusDB web3-ebakus: is an extentention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library: can be included on any static site and provide an interface to the ebakus blockchain through the web wallet. the ebakus web wallet: Is the interface to the ebakus network. The ebakus development stack allows for applications that are as easy to use as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models). The smart contract \u00b6 Smart contracts in the decentralized application context are the business logic and the blockchain is where they are stored and run. They are essentially the backend of the application and they are special because they are immutable and produce deterministic results run forever cost nothing to run for the developers As we mentioned before the ebakus node is 100% backwards compatible with ethereum. This allows you to use the vast resources available for developing smart contracts for solidity and apply everything you learn to ebakus to enjoy no fees, low latency and high throughput. Moreover ebakus extends solidity with ebakusDB a transactional decentralized Database that makes handling large datasets a breeze. You can try out examples and tutorials you find through the ebakus version of Remix IDE that will help you write, test and deploy solidity contracts for the ebakus network our own block explorer If you already understand the basics of developing smart contracts you may find interesting this article that introduces the ebakusDB . The client logic \u00b6 The client logic on the other hand works a bit differently as the ebakus development stack utilizes the embedded wallet that drastically improves usability. Lets see just how this works in a bit more detail. The proposed way to handle client logic uses three components the web3-ebakus: loads a web3 instance and extends it with web3 specific functions that allow you to access data stored in ebakusDB the wallet loader library: loads the ebakus web wallet in an iframe and provides an interface between your dApp and the ebakus wallet without giving you access to uses keys. This method of loading the wallet allows many dApps share the same wallet when running in the same browser. the ebakus web wallet hosted by a third party or yourself. Allows you to interface with the ebakus blockchain, send transactions, call contract functions and write data to the ebakusDB. if you already have a dApp running on ethereum or you are following a tutorial written for ethereum this article about migrating your ethereum based dApp to ebakus will be usefull.","title":"Gettting started with ebakus development"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#getting-started-with-ebakus-development","text":"ebakus based decentralized applications consist of two parts the business logic that is developed through smart contracts in the solidity language and runs on the ebakus network the client logic that interfaces with the smart contract. To enable developers produce highly responsive and frictionless decentralized applications that are a delight for users to use, we have created the ebakus development stack.","title":"Getting started with ebakus development"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#the-ebakus-development-stack","text":"The ebakus development stack consists of the ebakus node: DPOS, 1 second blocks, ebakusDB web3-ebakus: is an extentention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library: can be included on any static site and provide an interface to the ebakus blockchain through the web wallet. the ebakus web wallet: Is the interface to the ebakus network. The ebakus development stack allows for applications that are as easy to use as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models).","title":"The ebakus development stack"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#the-smart-contract","text":"Smart contracts in the decentralized application context are the business logic and the blockchain is where they are stored and run. They are essentially the backend of the application and they are special because they are immutable and produce deterministic results run forever cost nothing to run for the developers As we mentioned before the ebakus node is 100% backwards compatible with ethereum. This allows you to use the vast resources available for developing smart contracts for solidity and apply everything you learn to ebakus to enjoy no fees, low latency and high throughput. Moreover ebakus extends solidity with ebakusDB a transactional decentralized Database that makes handling large datasets a breeze. You can try out examples and tutorials you find through the ebakus version of Remix IDE that will help you write, test and deploy solidity contracts for the ebakus network our own block explorer If you already understand the basics of developing smart contracts you may find interesting this article that introduces the ebakusDB .","title":"The smart contract"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#the-client-logic","text":"The client logic on the other hand works a bit differently as the ebakus development stack utilizes the embedded wallet that drastically improves usability. Lets see just how this works in a bit more detail. The proposed way to handle client logic uses three components the web3-ebakus: loads a web3 instance and extends it with web3 specific functions that allow you to access data stored in ebakusDB the wallet loader library: loads the ebakus web wallet in an iframe and provides an interface between your dApp and the ebakus wallet without giving you access to uses keys. This method of loading the wallet allows many dApps share the same wallet when running in the same browser. the ebakus web wallet hosted by a third party or yourself. Allows you to interface with the ebakus blockchain, send transactions, call contract functions and write data to the ebakusDB. if you already have a dApp running on ethereum or you are following a tutorial written for ethereum this article about migrating your ethereum based dApp to ebakus will be usefull.","title":"The client logic"},{"location":"developing-applications-with-ebakus/migrating-your-ethereum-d-app-to-ebakus/","text":"Migrating your dApp from ethereum to ebakus \u00b6 While ethereum has been a pioneer in the blockchain space by enabling dApp development through smart contracts, nowadays dApps built on ethereum are decreasing in popularity and dApp developers are researching other platforms like EOS and Tron, that reduce the latency and throughput problem found in Ethereum while improving on accessibility. On this article we propose an alternative solution to Ethereum, EOS and Tron called ebakus, that further improves throughput and does leaps in terms of accessibility and usability. The best thing about ebakus is that it\u2019s pretty forward to migrate your ethereum dApp to, or start developing a new dApp from scratch if you have prior experience with Ethereum. You can read more about ebakus here and check how it compares as a platform to ethereum and EOS here . This article will focus on onboarding ethereum developers to ebakus and will also act as a guide on how to migrate your dApp to ebakus. Developing on ebakus for ethereum developers \u00b6 To remove friction for Ethereum devs, we designed ebakus to keep the ebakus node API to be the same as go-ethereum\u2019s ( geth ) and to also be compatible with web3. The only substantial difference is that in order to send transactions through webjs you need to use our web3-ebakus wrapper that extends it with the functions needed to calculate the POW. This means that dev tools built for ethereum\u2019s geth (like truffle) are also compatible with ebakus\u2019 node and dApps that use web3 (web3 version >1.x) to interface with their smart contracts are plug and play with ebakus. Improving accessibility and usability with ebakus\u2019 web wallet \u00b6 To further remove friction with ebakus, we have implemented a web wallet in the form of a JS library. This wallet can be embedded inside a dApp and along with the \u201cfree\u201d transactions model of ebakus, they provide a transparent (as far as the users are concerned) interface to the ebakus blockchain. The moment your dApp loads, the user is ready to interact with the blockchain. To further improve experience we went a step further and developed a wallet loader library that creates an iframe and loads a hosted version of the ebakus web wallet in it. This way multiple dApps can share the same wallet drastically improving the UX while also strengthening security. After downloading the wallet loader library from here all you have to do to load it in your project is to add the following in your dApp\u2019s html: < body > <!-- Body content... --> < script type = \u201dtext/javascript\u201d src = \u201dwallet-loader.min.js\u201d > </ script > </ body > If needed, you can then init the wallet with custom tokens with the following: < script > /* you can listen for `ebakusLoaded` event in order to know when wallet is ready */ window . addEventListener ( \u2018 ebakusLoaded \u2019 , ( ev ) => { console . warn ( \u2018 Ebakus Wallet loaded ! \u2019 ) /* loading custom token to wallet */ ebakusWallet . init ({ tokens : [{ contract_address : \u2018 0xa679d48c57320e9f0eadb043c3ea3f8dcd97ed01 \u2019 , symbol : \u2018 SIM \u2019 , decimals : 18 , }] }) /* Additional code */ < /script> After loading it, you can easily interface with the wallet through javascript the following functions: ebakusWallet .getDefaultAddress() as the name suggests, this function returns the wallet\u2019s address. (Current version of the webwallet only supports one address.) ebakusWallet .getBalance() returns the wallet\u2019s address\u2019 current balance in wei ebakusWallet. sendTransaction(tx_object) calls the wallet with a transaction object ( tx_object ). Your tx object here is the same as you would use it for ethereum. The wallet handles calculating POW, before sending the tx, in the background. ebakusWallet. suggestDifficulty(account_address) Returns the suggested target difficulty for your account taking into account your accounts stake and network congestion conditions. Further optimizations \u00b6 You may further want to optimize your dApp\u2019s code to take advantage of ebakus\u2019 lower latency(1 sec) and to leverage ebakusDB. EbakusDB allows you to use schema defined tables, with indexes that allows handling large datasets with ease. EbakusDB integration to EVM is already implemented and active in our testnet and an article describing how you can utilize it, is in the works. If you feel adventurous feel free to check out this indie leaderboard repository where we implement a leaderboard-achievements solution running completely decentralized on ebakus, leveraging ebakusDB. You can download and play with our boilerplate here You can also further study a real world migration example of an ethereum dApp to ebakus here","title":"Migrating your ethereum dApp to ebakus"},{"location":"developing-applications-with-ebakus/migrating-your-ethereum-d-app-to-ebakus/#migrating-your-dapp-from-ethereum-to-ebakus","text":"While ethereum has been a pioneer in the blockchain space by enabling dApp development through smart contracts, nowadays dApps built on ethereum are decreasing in popularity and dApp developers are researching other platforms like EOS and Tron, that reduce the latency and throughput problem found in Ethereum while improving on accessibility. On this article we propose an alternative solution to Ethereum, EOS and Tron called ebakus, that further improves throughput and does leaps in terms of accessibility and usability. The best thing about ebakus is that it\u2019s pretty forward to migrate your ethereum dApp to, or start developing a new dApp from scratch if you have prior experience with Ethereum. You can read more about ebakus here and check how it compares as a platform to ethereum and EOS here . This article will focus on onboarding ethereum developers to ebakus and will also act as a guide on how to migrate your dApp to ebakus.","title":"Migrating your dApp from ethereum to ebakus"},{"location":"developing-applications-with-ebakus/migrating-your-ethereum-d-app-to-ebakus/#developing-on-ebakus-for-ethereum-developers","text":"To remove friction for Ethereum devs, we designed ebakus to keep the ebakus node API to be the same as go-ethereum\u2019s ( geth ) and to also be compatible with web3. The only substantial difference is that in order to send transactions through webjs you need to use our web3-ebakus wrapper that extends it with the functions needed to calculate the POW. This means that dev tools built for ethereum\u2019s geth (like truffle) are also compatible with ebakus\u2019 node and dApps that use web3 (web3 version >1.x) to interface with their smart contracts are plug and play with ebakus.","title":"Developing on ebakus for ethereum developers"},{"location":"developing-applications-with-ebakus/migrating-your-ethereum-d-app-to-ebakus/#improving-accessibility-and-usability-with-ebakus-web-wallet","text":"To further remove friction with ebakus, we have implemented a web wallet in the form of a JS library. This wallet can be embedded inside a dApp and along with the \u201cfree\u201d transactions model of ebakus, they provide a transparent (as far as the users are concerned) interface to the ebakus blockchain. The moment your dApp loads, the user is ready to interact with the blockchain. To further improve experience we went a step further and developed a wallet loader library that creates an iframe and loads a hosted version of the ebakus web wallet in it. This way multiple dApps can share the same wallet drastically improving the UX while also strengthening security. After downloading the wallet loader library from here all you have to do to load it in your project is to add the following in your dApp\u2019s html: < body > <!-- Body content... --> < script type = \u201dtext/javascript\u201d src = \u201dwallet-loader.min.js\u201d > </ script > </ body > If needed, you can then init the wallet with custom tokens with the following: < script > /* you can listen for `ebakusLoaded` event in order to know when wallet is ready */ window . addEventListener ( \u2018 ebakusLoaded \u2019 , ( ev ) => { console . warn ( \u2018 Ebakus Wallet loaded ! \u2019 ) /* loading custom token to wallet */ ebakusWallet . init ({ tokens : [{ contract_address : \u2018 0xa679d48c57320e9f0eadb043c3ea3f8dcd97ed01 \u2019 , symbol : \u2018 SIM \u2019 , decimals : 18 , }] }) /* Additional code */ < /script> After loading it, you can easily interface with the wallet through javascript the following functions: ebakusWallet .getDefaultAddress() as the name suggests, this function returns the wallet\u2019s address. (Current version of the webwallet only supports one address.) ebakusWallet .getBalance() returns the wallet\u2019s address\u2019 current balance in wei ebakusWallet. sendTransaction(tx_object) calls the wallet with a transaction object ( tx_object ). Your tx object here is the same as you would use it for ethereum. The wallet handles calculating POW, before sending the tx, in the background. ebakusWallet. suggestDifficulty(account_address) Returns the suggested target difficulty for your account taking into account your accounts stake and network congestion conditions.","title":"Improving accessibility and usability with ebakus\u2019 web wallet"},{"location":"developing-applications-with-ebakus/migrating-your-ethereum-d-app-to-ebakus/#further-optimizations","text":"You may further want to optimize your dApp\u2019s code to take advantage of ebakus\u2019 lower latency(1 sec) and to leverage ebakusDB. EbakusDB allows you to use schema defined tables, with indexes that allows handling large datasets with ease. EbakusDB integration to EVM is already implemented and active in our testnet and an article describing how you can utilize it, is in the works. If you feel adventurous feel free to check out this indie leaderboard repository where we implement a leaderboard-achievements solution running completely decentralized on ebakus, leveraging ebakusDB. You can download and play with our boilerplate here You can also further study a real world migration example of an ethereum dApp to ebakus here","title":"Further optimizations"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/","text":"Public testnet v4 \u00b6 Ebakus Node \u00b6 Working with the ebakus full node \u00b6 Connecting to the public testnet with ebakus node \u00b6 $ ebakus --testnet console After the node syncs with the network you will be able to issue commands in the console. For example: > eth . getBlock ( 7 ) { delegateDiff : [ { DelegateAddress : \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\" , DelegateNumber : 0 , Pos : 0 },{ DelegateAddress : \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" , DelegateNumber : 0 , Pos : 1 } ], delegates : [ \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\" , \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" ], gasLimit : 6283185 , gasUsed : 54144 , hash : \"0x24ddb825da11ee358dc5715e9114aeb5b9e2bdd9515bf77dfe90be34388a9685\" , number : 7 , parentHash : \"0x6e42c2731e7fb8b50ffebf37fa4067b3af2ada342535ea1a1e0d5ea97dcaa1e1\" , producer : \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" , receiptsRoot : \"0x203b201c313a20355c1a137056b782c7572d3dee465e103708045cf33dbc8c95\" , size : 792 , timestamp : 1545512856 , transactions : [ \"0xda07c8239b27a0e0f0a25ac41fb090a0efefe3321d0f3c667bc85d9d57b3e6b9\" , \"0xcde95fc9b4295c0b4836dd0b77e663f072bdac2df16fd2a97b0fd64d4e016be9\" ], transactionsRoot : \"0x53c7a83d6024b31b8221c55f04ae666149cdbc968ccc39d2dd1481bd0affb13f\" } As you see the API follows the ethereum compatibility mode. The low level block structure however is different, and contains information relevant to DPOS and does not contain uncles, pow, and other ethereum related data. Using the javascript console of the Ebakus node you can deploy contracts and issue actions on existing contracts normally. Example of sending ebakus tokens: > eth . sendTransaction ({ from : '0xB2b3510C106E8e04Acfb9841e2213500167100f3' , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ) }) As you see, no gas needs to be spend, hence no gas price is set. Calculation of PoW for the transactions is automaticaly handled by sendTransaction. Deploying your Ethereum Contracts on Ebakus \u00b6 Compile your contract solcjs --abi game.sol solcjs --bin game.sol Display the compiled code on the console more game_sol_game.abi more game_sol_game.bin We continue on our ebakus node $ ebakus --testnet --verbosity = 2 console You should see this: Welcome to the Ebakus JavaScript console ! instance : Ebakus / v1 .8.20 - unstable / darwin - amd64 / go1 .11.2 coinbase : 0x32f14386cea573bba82282b6f449ee77030a96e2 at block : 89471 ( Mon , 24 Dec 2018 00 : 00 : 38 EET ) datadir : /Users/harkal/ebakus2 modules : admin : 1.0 debug : 1.0 dpos : 1.0 eth : 1.0 miner : 1.0 net : 1.0 personal : 1.0 rpc : 1.0 txpool : 1.0 web3 : 1.0 > Unlock you account > personal . unlockAccount ( eth . coinbase ) Unlock account 0 x .... Passphrase : [ ENTER PASSPHRASE ] Setup abi and bytecode > var myContract = eth . contract ([ CONTENTS OF ABI FILE ]) > var bytecode = '0x[CONTENTS OF BIN FILE]' Tip Replace [CONTENTS OF ABI FILE] and [CONTENTS OF BIN FILE] with the outputs of the more commands that should still be open in another terminal window. Deploy > var game = myContract . new ({ from : eth . coinbase , data : bytecode , gas : 2000000 }) Interact with contract > game . playMove ( 'forward' ) Running a local development testnet \u00b6 Running the first node \u00b6 $ export EBAKUS_DATADIR = /tmp/eth/1 $ mkdir -p $EBAKUS_DATADIR && ebakus --datadir = $EBAKUS_DATADIR -verbosity 9 -- testnet --preload ~/ebakus/scripts/ebakus-load.js --nodiscover console 2 >> $EBAKUS_DATADIR /ebakus.log Running the second node (optional) \u00b6 $ export EBAKUS_DATADIR = /tmp/eth/2 $ mkdir -p $EBAKUS_DATADIR && ebakus --datadir = $EBAKUS_DATADIR -verbosity 9 -- testnet --preload ~/ebakus/scripts/ebakus-load.js --nodiscover --port 30404 console 2 >> $EBAKUS_DATADIR /ebakus.log The ~/ebakus/scripts/ebakus-load.js script contains some quick access utility functions as can be the following: /* * Developer helpful functions for Ebakus node! */ /* * -- Helpful constants */ var DEV_ACCOUNTS = { producer : { address : \"0xB2b3510C106E8e04Acfb9841e2213500167100f3\" , prv : \"32883cebda1636ff41895b8425feee5622b074545e74db7091fa216d7ddb39d4\" , pass : \"Ebakus123\" // unlocked: false, }, simple : { address : \"0x8f10d3a6283672ecfaeea0377d460bded489ec44\" , prv : \"90308da4eedf50472684b0b7bcd51b55bec149a4bc7135ccfc9c87ade7efc9b5\" , pass : \"Ebakus123\" } }; /* * -------- Accounts ----------- */ // Import an account from the predefined DEV_ACCOUNTS constant function eAccountImport ( account ) { if ( personal . listAccounts . indexOf ( account . address . toLowerCase ()) > - 1 ) { return ; } personal . importRawKey ( account . prv , account . pass ); } // Unlock account function eAccountUnlock ( account ) { if ( account . unlocked ) { return true ; } // store unlocked state in DEV_ACCOUNTS account . unlocked = true ; console . log ( 'Account \"' + account . address + '\" unlocked!' ); // unlock producer account return personal . unlockAccount ( account . address , account . pass , 0 ); } // Unlock producer account function eAccountProducerUnlock () { return eAccountUnlock ( DEV_ACCOUNTS . producer ); } // Print balances for all account function eCheckAllBalances () { var totalBal = 0 ; for ( var acctNum in eth . accounts ) { var acct = eth . accounts [ acctNum ]; var acctBal = web3 . fromWei ( eth . getBalance ( acct ), \"ether\" ); totalBal += parseFloat ( acctBal ); console . log ( \" eth.accounts[\" + acctNum + \"]: \\t\" + acct + \" \\tbalance: \" + acctBal + \" ether\" ); } console . log ( \" Total balance: \" + totalBal + \" ether\" ); } /* * -------- Mining ----------- */ // Start mining function eMiner () { eAccountProducerUnlock (); // start miner return miner . start (); } /* * -------- Transactions ----------- */ // Producer send ether to simple account function eProducerSendEbakusToSimple ( amount ) { var producerAccount = DEV_ACCOUNTS . producer ; eAccountUnlock ( producerAccount ); return eth . sendTransaction ({ from : producerAccount . address , to : DEV_ACCOUNTS . simple . address , value : web3 . toWei ( amount || 0.01 , \"ether\" ) }); } function _bootstrap () { console . info ( \"JS Development helper has been loaded!\" ); // import producer account, once eAccountImport ( DEV_ACCOUNTS . producer ); // import another account, once eAccountImport ( DEV_ACCOUNTS . simple ); // loadScript('~/ebakus/scripts/another-script.js'); } // run on load _bootstrap ();","title":"Running a local testnet"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#public-testnet-v4","text":"","title":"Public testnet v4"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#ebakus-node","text":"","title":"Ebakus Node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#working-with-the-ebakus-full-node","text":"","title":"Working with the ebakus full node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#connecting-to-the-public-testnet-with-ebakus-node","text":"$ ebakus --testnet console After the node syncs with the network you will be able to issue commands in the console. For example: > eth . getBlock ( 7 ) { delegateDiff : [ { DelegateAddress : \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\" , DelegateNumber : 0 , Pos : 0 },{ DelegateAddress : \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" , DelegateNumber : 0 , Pos : 1 } ], delegates : [ \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\" , \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" ], gasLimit : 6283185 , gasUsed : 54144 , hash : \"0x24ddb825da11ee358dc5715e9114aeb5b9e2bdd9515bf77dfe90be34388a9685\" , number : 7 , parentHash : \"0x6e42c2731e7fb8b50ffebf37fa4067b3af2ada342535ea1a1e0d5ea97dcaa1e1\" , producer : \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" , receiptsRoot : \"0x203b201c313a20355c1a137056b782c7572d3dee465e103708045cf33dbc8c95\" , size : 792 , timestamp : 1545512856 , transactions : [ \"0xda07c8239b27a0e0f0a25ac41fb090a0efefe3321d0f3c667bc85d9d57b3e6b9\" , \"0xcde95fc9b4295c0b4836dd0b77e663f072bdac2df16fd2a97b0fd64d4e016be9\" ], transactionsRoot : \"0x53c7a83d6024b31b8221c55f04ae666149cdbc968ccc39d2dd1481bd0affb13f\" } As you see the API follows the ethereum compatibility mode. The low level block structure however is different, and contains information relevant to DPOS and does not contain uncles, pow, and other ethereum related data. Using the javascript console of the Ebakus node you can deploy contracts and issue actions on existing contracts normally. Example of sending ebakus tokens: > eth . sendTransaction ({ from : '0xB2b3510C106E8e04Acfb9841e2213500167100f3' , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ) }) As you see, no gas needs to be spend, hence no gas price is set. Calculation of PoW for the transactions is automaticaly handled by sendTransaction.","title":"Connecting to the public testnet with ebakus node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#deploying-your-ethereum-contracts-on-ebakus","text":"Compile your contract solcjs --abi game.sol solcjs --bin game.sol Display the compiled code on the console more game_sol_game.abi more game_sol_game.bin We continue on our ebakus node $ ebakus --testnet --verbosity = 2 console You should see this: Welcome to the Ebakus JavaScript console ! instance : Ebakus / v1 .8.20 - unstable / darwin - amd64 / go1 .11.2 coinbase : 0x32f14386cea573bba82282b6f449ee77030a96e2 at block : 89471 ( Mon , 24 Dec 2018 00 : 00 : 38 EET ) datadir : /Users/harkal/ebakus2 modules : admin : 1.0 debug : 1.0 dpos : 1.0 eth : 1.0 miner : 1.0 net : 1.0 personal : 1.0 rpc : 1.0 txpool : 1.0 web3 : 1.0 > Unlock you account > personal . unlockAccount ( eth . coinbase ) Unlock account 0 x .... Passphrase : [ ENTER PASSPHRASE ] Setup abi and bytecode > var myContract = eth . contract ([ CONTENTS OF ABI FILE ]) > var bytecode = '0x[CONTENTS OF BIN FILE]' Tip Replace [CONTENTS OF ABI FILE] and [CONTENTS OF BIN FILE] with the outputs of the more commands that should still be open in another terminal window. Deploy > var game = myContract . new ({ from : eth . coinbase , data : bytecode , gas : 2000000 }) Interact with contract > game . playMove ( 'forward' )","title":"Deploying your Ethereum Contracts on Ebakus"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#running-a-local-development-testnet","text":"","title":"Running a local development testnet"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#running-the-first-node","text":"$ export EBAKUS_DATADIR = /tmp/eth/1 $ mkdir -p $EBAKUS_DATADIR && ebakus --datadir = $EBAKUS_DATADIR -verbosity 9 -- testnet --preload ~/ebakus/scripts/ebakus-load.js --nodiscover console 2 >> $EBAKUS_DATADIR /ebakus.log","title":"Running the first node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#running-the-second-node-optional","text":"$ export EBAKUS_DATADIR = /tmp/eth/2 $ mkdir -p $EBAKUS_DATADIR && ebakus --datadir = $EBAKUS_DATADIR -verbosity 9 -- testnet --preload ~/ebakus/scripts/ebakus-load.js --nodiscover --port 30404 console 2 >> $EBAKUS_DATADIR /ebakus.log The ~/ebakus/scripts/ebakus-load.js script contains some quick access utility functions as can be the following: /* * Developer helpful functions for Ebakus node! */ /* * -- Helpful constants */ var DEV_ACCOUNTS = { producer : { address : \"0xB2b3510C106E8e04Acfb9841e2213500167100f3\" , prv : \"32883cebda1636ff41895b8425feee5622b074545e74db7091fa216d7ddb39d4\" , pass : \"Ebakus123\" // unlocked: false, }, simple : { address : \"0x8f10d3a6283672ecfaeea0377d460bded489ec44\" , prv : \"90308da4eedf50472684b0b7bcd51b55bec149a4bc7135ccfc9c87ade7efc9b5\" , pass : \"Ebakus123\" } }; /* * -------- Accounts ----------- */ // Import an account from the predefined DEV_ACCOUNTS constant function eAccountImport ( account ) { if ( personal . listAccounts . indexOf ( account . address . toLowerCase ()) > - 1 ) { return ; } personal . importRawKey ( account . prv , account . pass ); } // Unlock account function eAccountUnlock ( account ) { if ( account . unlocked ) { return true ; } // store unlocked state in DEV_ACCOUNTS account . unlocked = true ; console . log ( 'Account \"' + account . address + '\" unlocked!' ); // unlock producer account return personal . unlockAccount ( account . address , account . pass , 0 ); } // Unlock producer account function eAccountProducerUnlock () { return eAccountUnlock ( DEV_ACCOUNTS . producer ); } // Print balances for all account function eCheckAllBalances () { var totalBal = 0 ; for ( var acctNum in eth . accounts ) { var acct = eth . accounts [ acctNum ]; var acctBal = web3 . fromWei ( eth . getBalance ( acct ), \"ether\" ); totalBal += parseFloat ( acctBal ); console . log ( \" eth.accounts[\" + acctNum + \"]: \\t\" + acct + \" \\tbalance: \" + acctBal + \" ether\" ); } console . log ( \" Total balance: \" + totalBal + \" ether\" ); } /* * -------- Mining ----------- */ // Start mining function eMiner () { eAccountProducerUnlock (); // start miner return miner . start (); } /* * -------- Transactions ----------- */ // Producer send ether to simple account function eProducerSendEbakusToSimple ( amount ) { var producerAccount = DEV_ACCOUNTS . producer ; eAccountUnlock ( producerAccount ); return eth . sendTransaction ({ from : producerAccount . address , to : DEV_ACCOUNTS . simple . address , value : web3 . toWei ( amount || 0.01 , \"ether\" ) }); } function _bootstrap () { console . info ( \"JS Development helper has been loaded!\" ); // import producer account, once eAccountImport ( DEV_ACCOUNTS . producer ); // import another account, once eAccountImport ( DEV_ACCOUNTS . simple ); // loadScript('~/ebakus/scripts/another-script.js'); } // run on load _bootstrap ();","title":"Running the second node (optional)"},{"location":"developing-applications-with-ebakus/using-ebakus-db/","text":"Using ebakusDB in Solidity \u00b6 Introduction \u00b6 Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/update/delete single or multiple rows of data Do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance. How to install \u00b6 Truffle Installation \u00b6 version 5.0.0 First install truffle via npm using npm install -g truffle . Please visit Truffle\u2019s installation guide for further information and requirements. Manual install: \u00b6 This process will allow you to both link your contract to the current on-chain library as well as deploy it in your local environment for development. Place the EbakusDB.sol file in your truffle contracts/ directory. Place the EbakusDB.json file in your truffle build/contracts/ directory. Amend the deployment.js file in your truffle migrations/ directory as follows: var EbakusDB = artifacts . require ( 'EbakusDB' ); var YourContract = artifacts . require ( \"./YourContract.sol\" ); ... module . exports = function ( deployer ) { deployer . deploy ( EbakusDB , { overwrite : false }); deployer . link ( EbakusDB , YourContract ); deployer . deploy ( YourContract ); }; !!!Note: The .link() function should be called before you .deploy(YourStandardTokenContract) . Also, be sure to include the {overwrite: false} when writing the deployer i.e. .deploy(TokenLib, {overwrite: false}) . This prevents deploying the library onto the main network at your cost and uses the library already on the blockchain. The function should still be called however because it allows you to use it in your development environment. See below Usage Example \u00b6 You can read about available EbakusDB methods and their documentation inline here . You can find an example contract using the EbakusDB here . pragma solidity ^ 0.5 . 0 ; import \"./EbakusDB.sol\" ; contract Example { string TableName = \"Users\" ; struct User { uint64 Id ; string Name ; string Pass ; } constructor () public { string memory tablesAbi = '[{\"type\":\"table\",\"name\":\"Users\",\"inputs\":[{\"name\":\"Id\",\"type\":\"uint64\"},{\"name\":\"Name\",\"type\":\"string\"},{\"name\":\"Pass\",\"type\":\"string\"}]}]' ; EbakusDB . createTable ( TableName , \"Name\" , tablesAbi ); } function main () external { // Insert entry User memory u = User ( 1 , \"Harry\" , \"123\" ); bytes memory input = abi . encode ( u . Id , u . Name , u . Pass ); EbakusDB . insertObj ( TableName , input ); // Get back entry User memory u1 ; bytes memory out = EbakusDB . get ( TableName , \"Name\" , \"Harry\" ); ( u1 . Id , u1 . Name , u1 . Pass ) = abi . decode ( out , ( uint64 , string , string )); } ... }","title":"Using ebakusDB"},{"location":"developing-applications-with-ebakus/using-ebakus-db/#using-ebakusdb-in-solidity","text":"","title":"Using ebakusDB in Solidity"},{"location":"developing-applications-with-ebakus/using-ebakus-db/#introduction","text":"Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/update/delete single or multiple rows of data Do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance.","title":"Introduction"},{"location":"developing-applications-with-ebakus/using-ebakus-db/#how-to-install","text":"","title":"How to install"},{"location":"developing-applications-with-ebakus/using-ebakus-db/#truffle-installation","text":"version 5.0.0 First install truffle via npm using npm install -g truffle . Please visit Truffle\u2019s installation guide for further information and requirements.","title":"Truffle Installation"},{"location":"developing-applications-with-ebakus/using-ebakus-db/#manual-install","text":"This process will allow you to both link your contract to the current on-chain library as well as deploy it in your local environment for development. Place the EbakusDB.sol file in your truffle contracts/ directory. Place the EbakusDB.json file in your truffle build/contracts/ directory. Amend the deployment.js file in your truffle migrations/ directory as follows: var EbakusDB = artifacts . require ( 'EbakusDB' ); var YourContract = artifacts . require ( \"./YourContract.sol\" ); ... module . exports = function ( deployer ) { deployer . deploy ( EbakusDB , { overwrite : false }); deployer . link ( EbakusDB , YourContract ); deployer . deploy ( YourContract ); }; !!!Note: The .link() function should be called before you .deploy(YourStandardTokenContract) . Also, be sure to include the {overwrite: false} when writing the deployer i.e. .deploy(TokenLib, {overwrite: false}) . This prevents deploying the library onto the main network at your cost and uses the library already on the blockchain. The function should still be called however because it allows you to use it in your development environment. See below","title":"Manual install:"},{"location":"developing-applications-with-ebakus/using-ebakus-db/#usage-example","text":"You can read about available EbakusDB methods and their documentation inline here . You can find an example contract using the EbakusDB here . pragma solidity ^ 0.5 . 0 ; import \"./EbakusDB.sol\" ; contract Example { string TableName = \"Users\" ; struct User { uint64 Id ; string Name ; string Pass ; } constructor () public { string memory tablesAbi = '[{\"type\":\"table\",\"name\":\"Users\",\"inputs\":[{\"name\":\"Id\",\"type\":\"uint64\"},{\"name\":\"Name\",\"type\":\"string\"},{\"name\":\"Pass\",\"type\":\"string\"}]}]' ; EbakusDB . createTable ( TableName , \"Name\" , tablesAbi ); } function main () external { // Insert entry User memory u = User ( 1 , \"Harry\" , \"123\" ); bytes memory input = abi . encode ( u . Id , u . Name , u . Pass ); EbakusDB . insertObj ( TableName , input ); // Get back entry User memory u1 ; bytes memory out = EbakusDB . get ( TableName , \"Name\" , \"Harry\" ); ( u1 . Id , u1 . Name , u1 . Pass ) = abi . decode ( out , ( uint64 , string , string )); } ... }","title":"Usage Example"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/","text":"","title":"Ebakus node"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-wallet/","text":"","title":"Ebakus wallet"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/","text":"","title":"Wallet loader"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/","text":"web3-ebakus library for web3.js \u00b6 Extend Web3.js functionality for Ebakus blockchain. Installation \u00b6 Node.js \u00b6 npm install --save web3-ebakus In the Browser \u00b6 Load it from CDN: <script src= \"https://unpkg.com/web3-ebakus\" ></script> or build running the following from the root folder of the repository: npm run-script build Then include lib/web3-ebakus.browser.min.js in your html file. This will expose the Web3Ebakus object on the window object. Requirements \u00b6 Web3 ^1.2.0 Usage \u00b6 import Web3Ebakus from 'web3-ebakus' import Web3 from 'web3' const web3 = Web3Ebakus ( new Web3 ()) You can also have a look at the example page . Methods \u00b6 web3.eth.suggestDifficulty(accountAddress) \u00b6 The suggestDifficulty queries the node for the suggested target difficulty needed for the PoW in order for a transaction to enter a block taking into account current congestion levels and address stake. The difficulty will be used in calculateWorkForTransaction . web3 . eth . suggestDifficulty ( accountAddress ) . then ( difficulty => console . log ( difficulty )) web3.eth.calculateWorkForTransaction(transaction, targetDifficulty, ctrlWorkForTransactionState, callback) \u00b6 The calculateWorkForTransaction calculates the PoW needed for a transaction to enter a block by a block producer. const tx = { /* transaction object */ } web3 . eth . calculateWorkForTransaction ( tx , /* targetDifficulty */ 1 ) . then ( tx => { /* do something with tx */ }) is also available for Account objects, which is useful for chaining The ctrlWorkForTransactionState and callback parameters are optional. ctrlWorkForTransactionState : this is an object that will be populated with some useful methods when passed. isRunning() : state of worker getCurrentWorkNonce() : returns the current workNonce while worker is running kill() : kills the worker Example let ctrl = {} // log worker state every 500ms const logger = setInterval (() => { console . log ( 'isRunning' , ctrl . isRunning ()) console . log ( 'getCurrentWorkNonce' , ctrl . getCurrentWorkNonce ()) // stop logging once worker finished if ( ! ctrl . isRunning ()) { clearInterval ( logger ) } }, 500 ) // kill worker after 3seconds // setTimeout(() => { // ctrl.kill(); // }, 3000); web3 . eth . calculateWorkForTransaction ( transaction , 1 , ctrl ). then ( tx => { /* do something with tx */ }) callback : you can read more here web3.db.select(contractAddress, tableName, whereCondition, orderByColumn, blockNumber) \u00b6 The db.select allows performing selects with conditions ordered by column name. contractAddress : contract address that created the DB tables tableName : table name whereClause : where condition for finding an entry Supported conditions are \u201c<\u201d, \u201c>\u201d, \u201c=\u201d, \u201c==\u201d, \u201c<=\u201d, \u201c>=\u201d, \u201c!=\u201d, \u201cLIKE\u201d Example use cases Phone = \"555-1111\" , Id >= 3 orderClause : order clause for sorting the results using \u201cASC\u201d or \u201cDESC\u201d Example use case: Phone DESC blockNumber : block number to read from EbakusDB state. You can use latest string for fetching from latest block. web3 . db . select ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( iterator => web3 . db . next ( iter ). then ( entry => console . log ( entry ) ) web3.db.next(iter) \u00b6 The db.next returns the next result of the select performed through web3.db.select() . web3.db.get(contractAddress, tableName, whereCondition, orderByColumn, blockNumber) \u00b6 The db.get allows fetching a single item. Check for its params at web3.db.select() . web3 . db . get ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( entry => console . log ( entry ))","title":"web3-ebakus"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3-ebakus-library-for-web3js","text":"Extend Web3.js functionality for Ebakus blockchain.","title":"web3-ebakus library for web3.js"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#installation","text":"","title":"Installation"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#nodejs","text":"npm install --save web3-ebakus","title":"Node.js"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#in-the-browser","text":"Load it from CDN: <script src= \"https://unpkg.com/web3-ebakus\" ></script> or build running the following from the root folder of the repository: npm run-script build Then include lib/web3-ebakus.browser.min.js in your html file. This will expose the Web3Ebakus object on the window object.","title":"In the Browser"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#requirements","text":"Web3 ^1.2.0","title":"Requirements"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#usage","text":"import Web3Ebakus from 'web3-ebakus' import Web3 from 'web3' const web3 = Web3Ebakus ( new Web3 ()) You can also have a look at the example page .","title":"Usage"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#methods","text":"","title":"Methods"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethsuggestdifficultyaccountaddress","text":"The suggestDifficulty queries the node for the suggested target difficulty needed for the PoW in order for a transaction to enter a block taking into account current congestion levels and address stake. The difficulty will be used in calculateWorkForTransaction . web3 . eth . suggestDifficulty ( accountAddress ) . then ( difficulty => console . log ( difficulty ))","title":"web3.eth.suggestDifficulty(accountAddress)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethcalculateworkfortransactiontransaction-targetdifficulty-ctrlworkfortransactionstate-callback","text":"The calculateWorkForTransaction calculates the PoW needed for a transaction to enter a block by a block producer. const tx = { /* transaction object */ } web3 . eth . calculateWorkForTransaction ( tx , /* targetDifficulty */ 1 ) . then ( tx => { /* do something with tx */ }) is also available for Account objects, which is useful for chaining The ctrlWorkForTransactionState and callback parameters are optional. ctrlWorkForTransactionState : this is an object that will be populated with some useful methods when passed. isRunning() : state of worker getCurrentWorkNonce() : returns the current workNonce while worker is running kill() : kills the worker Example let ctrl = {} // log worker state every 500ms const logger = setInterval (() => { console . log ( 'isRunning' , ctrl . isRunning ()) console . log ( 'getCurrentWorkNonce' , ctrl . getCurrentWorkNonce ()) // stop logging once worker finished if ( ! ctrl . isRunning ()) { clearInterval ( logger ) } }, 500 ) // kill worker after 3seconds // setTimeout(() => { // ctrl.kill(); // }, 3000); web3 . eth . calculateWorkForTransaction ( transaction , 1 , ctrl ). then ( tx => { /* do something with tx */ }) callback : you can read more here","title":"web3.eth.calculateWorkForTransaction(transaction, targetDifficulty, ctrlWorkForTransactionState, callback)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbselectcontractaddress-tablename-wherecondition-orderbycolumn-blocknumber","text":"The db.select allows performing selects with conditions ordered by column name. contractAddress : contract address that created the DB tables tableName : table name whereClause : where condition for finding an entry Supported conditions are \u201c<\u201d, \u201c>\u201d, \u201c=\u201d, \u201c==\u201d, \u201c<=\u201d, \u201c>=\u201d, \u201c!=\u201d, \u201cLIKE\u201d Example use cases Phone = \"555-1111\" , Id >= 3 orderClause : order clause for sorting the results using \u201cASC\u201d or \u201cDESC\u201d Example use case: Phone DESC blockNumber : block number to read from EbakusDB state. You can use latest string for fetching from latest block. web3 . db . select ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( iterator => web3 . db . next ( iter ). then ( entry => console . log ( entry ) )","title":"web3.db.select(contractAddress, tableName, whereCondition, orderByColumn, blockNumber)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbnextiter","text":"The db.next returns the next result of the select performed through web3.db.select() .","title":"web3.db.next(iter)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbgetcontractaddress-tablename-wherecondition-orderbycolumn-blocknumber","text":"The db.get allows fetching a single item. Check for its params at web3.db.select() . web3 . db . get ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( entry => console . log ( entry ))","title":"web3.db.get(contractAddress, tableName, whereCondition, orderByColumn, blockNumber)"}]}